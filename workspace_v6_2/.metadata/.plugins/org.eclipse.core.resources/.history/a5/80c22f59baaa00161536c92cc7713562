/*
 * driver_aktorik.c
 *
 *  Created on: 31. Okt. 2016
 *      Author: KlotzSeb
 */
#include <msp430.h>
#include "..\HAL\hal_timerA1.h"
#include "driver_aktorik.h"


extern int initcounter;    //Zählt bei PWM-Interrupt (Periode) hoch  Counts up when Pwm-Interrupt is set. (Every PWM-Period)
int state=0;


void Driver_SetSteering (int SteeringAngle)  //Void funktion. Eingabe: -100% bis +100% Links ist minus Rechts ist plus
{
	int StPWM = 0;
							// Mittelpunktkalibrrierung ist wichtig!!!!
	if ((SteeringAngle < 0) && (SteeringAngle >= -100) ) //Lenkunk nach link und kleiner als 100%, 100% entspricht dem linken Anschlagspunkt, über 100% kann die LEnkung zerstören
	{
		StPWM = StPWM_middle+(SteeringAngle * res_left); // PWM-Wrt wird berechnet. PWM=PWM_Mitte - X% * (PWM_mitte-Anschlag_links)/100
	}
	else if ((SteeringAngle > 0) && (SteeringAngle <= 100))
	{
		StPWM = StPWM_middle+ (SteeringAngle * res_right); //PWM=PWM_Mitte + X% * (Anschlag_Rechts-PWM_mitte)/100
	}
	else if (SteeringAngle > 100)
	{
		StPWM = StPWM_full_right;
	}
	else if (SteeringAngle < -100)
	{
		StPWM = StPWM_full_left;
	}
	else
	{
		StPWM = StPWM_middle;
	}

	if((StPWM >= StPWM_full_left) && (StPWM <= StPWM_full_right))
	{
		TA1CCR2=StPWM;
	}  //Beschreiben der Compare-Registers  PWM setzen
	else
	{
		StPWM=StPWM_middle;
	}


}

void Driver_ESCInit(void)
{
///  3 Perioden Random PWM
/// 140 PErioden Maximal Rückwärts also 1ms pwm   140 Perioden
/// 140 Perioden Minimal Rückwärts also 1.2ms

//  140 Perioden mimnimal Gas 1.6ms
/// 140 Perioden Maximal Gas  2ms
//  140 Perioden Maximal Brake 1.4ms

		Driver_PWMInit(2500,3);// in PWM Modus
		// __delay_cycles(5000);
		Driver_PWMInit(MaxRPW,140);// MAX rpw
		//__delay_cycles(5000);
		Driver_PWMInit(MinRPW,140);// Min Rpw
		// __delay_cycles(5000);
		Driver_PWMInit(MinFPW,140);// Min FPW
		//__delay_cycles(5000);
		Driver_PWMInit(MaxFPW,140);// Max FPW
		//__delay_cycles(5000);
		Driver_PWMInit(MaxBRK,140);// Max Brake


}


void Driver_SetThrottle (int Throttle)  		//Gasgeben
{
	int ThPWM=0;
	if((Throttle >= 0)&&(Throttle <= 100))  	//Gasbereich begrenzen
	{
		ThPWM= MinFPW+res_throttle*Throttle; 	 // Pwm= PWM0Gas+ Throttle* (PWMMaxGas-PWM0Gas)/100
	}
	if((ThPWM>=MinFPW)&&(ThPWM<=MaxFPW))  		//Vorsichtsmaßnahme, damit wirklich keine falsche PWM gesetzt wird
	{
		TA1CCR1 = ThPWM;
	}
	state=1;
}

void Driver_SetBrake (int Brake)
{

	int BrPWM=0;
	if((Brake >= 0)&&(Brake <= 100))  	//Gasbereich begrenzen
	{
		if (state==1)
		{
			ThPWM = MinFPW-res_brk*Brake;
		}// Pwm= PWM0Gas+ Throttle* (PWMMaxGas-PWM0Gas)/100
	}
	if((ThPWM>=MaxBRK)&&(ThPWM<=MinFPW))  		//Vorsichtsmaßnahme, damit wirklich keine falsche PWM gesetzt wird
	{
		TA1CCR1 = ThPWM;
	}
}

void Driver_SetBack(int Backwards)
{
	state=2;
}

void Driver_PWMInit(int PWM, int cycle)
{
	initcounter = 0;
	while(initcounter <= cycle)
	{
		TA1CCR1 = PWM;
	}
}
